import os
import json
import random
import traceback
from google.oauth2.service_account import Credentials
from googleapiclient.discovery import build
from datetime import datetime
from typing import List, Dict, Optional

class GoogleSheetsServiceAccountService:
    """
    Servi√ßo para Google Sheets usando Service Account
    Mais simples que OAuth2 - ideal para aplica√ß√µes server-side
    """
    
    def __init__(self, spreadsheet_id: str, range_name: str = 'Clientes!A:CZ'):
        self.spreadsheet_id = spreadsheet_id
        self.range_name = range_name
        self.service = None
        self.scopes = ['https://www.googleapis.com/auth/spreadsheets']
        
        print(f"üîß Service Account Service inicializado para planilha: {self.spreadsheet_id}")
        self._authenticate()
        
        # Garantir que os cabe√ßalhos estejam na ordem correta
        self.ensure_correct_headers()
    
    def _authenticate(self):
        """Autentica usando Service Account (local ou vari√°vel de ambiente)"""
        try:
            # Tenta primeiro vari√°vel de ambiente (produ√ß√£o)
            service_account_json = os.environ.get('GOOGLE_SERVICE_ACCOUNT_JSON')
            
            if service_account_json:
                print("üîê Usando credenciais da vari√°vel de ambiente (produ√ß√£o)")
                print(f"üîç Tamanho da vari√°vel: {len(service_account_json)} caracteres")
                print(f"üîç Primeiros 50 caracteres: {service_account_json[:50]}...")
                
                try:
                    credentials_info = json.loads(service_account_json)
                    print(f"‚úÖ JSON parseado com sucesso!")
                    print(f"üîç Chaves do JSON: {list(credentials_info.keys())}")
                    print(f"üîç Project ID: {credentials_info.get('project_id', 'N/A')}")
                    print(f"üîç Client Email: {credentials_info.get('client_email', 'N/A')}")
                    
                    credentials = Credentials.from_service_account_info(
                        credentials_info, scopes=self.scopes
                    )
                    print("‚úÖ Credenciais Service Account criadas da vari√°vel de ambiente!")
                    
                except json.JSONDecodeError as json_error:
                    print(f"‚ùå Erro ao fazer parse do JSON da vari√°vel de ambiente: {json_error}")
                    print(f"‚ùå Conte√∫do da vari√°vel (primeiros 200 chars): {service_account_json[:200]}")
                    raise
                    
            else:
                # Fallback para arquivo local (desenvolvimento)
                print("üîê Vari√°vel de ambiente n√£o encontrada, tentando arquivo local...")
                current_dir = os.path.dirname(os.path.dirname(__file__))
                credentials_file = os.path.join(current_dir, 'service-account-key.json')
                print(f"üìÅ Procurando credenciais em: {credentials_file}")
                
                if not os.path.exists(credentials_file):
                    raise FileNotFoundError(f"Arquivo de credenciais n√£o encontrado: {credentials_file}")
                    
                print("‚úÖ Arquivo de credenciais encontrado!")
                credentials = Credentials.from_service_account_file(
                    credentials_file, scopes=self.scopes
                )
                print("‚úÖ Credenciais Service Account criadas do arquivo local!")
            
            print("üîê Autenticando com Service Account...")
            print(f"üîç Scopes solicitados: {self.scopes}")
            
            self.service = build('sheets', 'v4', credentials=credentials)
            print("‚úÖ Autentica√ß√£o Service Account conclu√≠da!")
            
            # Testar a conex√£o fazendo uma requisi√ß√£o simples
            print("üîç Testando conex√£o com Google Sheets...")
            try:
                # Tentar obter metadados da planilha
                spreadsheet = self.service.spreadsheets().get(
                    spreadsheetId=self.spreadsheet_id
                ).execute()
                
                sheet_title = spreadsheet.get('properties', {}).get('title', 'N/A')
                sheet_count = len(spreadsheet.get('sheets', []))
                print(f"‚úÖ Conex√£o testada com sucesso!")
                print(f"üìä Planilha: '{sheet_title}' com {sheet_count} aba(s)")
                
            except Exception as test_error:
                print(f"‚ùå Erro ao testar conex√£o: {test_error}")
                print(f"‚ùå Spreadsheet ID usado: {self.spreadsheet_id}")
                raise
            
        except Exception as e:
            print(f"‚ùå Erro na autentica√ß√£o Service Account: {e}")
            print(f"‚ùå Tipo do erro: {type(e).__name__}")
            import traceback
            print(f"‚ùå Traceback completo: {traceback.format_exc()}")
            raise
    
    def save_client(self, client: Dict) -> bool:
        """Salva ou atualiza cliente no Google Sheets - CORRIGIDO PARA EVITAR DUPLICA√á√ÉO"""
        try:
            print(f"üîç [SERVICE] ===== PROCESSANDO CLIENTE =====")
            print(f"üîç [SERVICE] Cliente: '{client.get('nomeEmpresa')}'")
            print(f"üîç [SERVICE] ID do cliente: '{client.get('id')}'")
            print(f"üîç [SERVICE] Dados recebidos: {list(client.keys())}")
            
            client_id = client.get('id')
            
            # VALIDA√á√ÉO RIGOROSA: Verificar se o ID √© v√°lido
            if client_id and str(client_id).strip() and str(client_id) != 'None':
                print("üîç [SERVICE] ===== OPERA√á√ÉO: ATUALIZA√á√ÉO =====")
                print(f"üîç [SERVICE] Verificando se cliente ID '{client_id}' existe...")
                
                # Buscar linha do cliente
                row_index = self.find_client_row(client_id)
                
                if row_index > 0:
                    print(f"‚úÖ [SERVICE] Cliente existe na linha {row_index} - ATUALIZANDO")
                    return self.update_client(client)
                else:
                    print(f"‚ö†Ô∏è [SERVICE] Cliente ID '{client_id}' N√ÉO encontrado!")
                    print(f"‚ö†Ô∏è [SERVICE] Isso pode indicar:")
                    print(f"   - ID inv√°lido ou corrompido")
                    print(f"   - Cliente foi deletado")
                    print(f"   - Problemas na planilha")
                    print(f"‚ùå [SERVICE] ABORTANDO opera√ß√£o para evitar duplica√ß√£o")
                    return False
            else:
                print("üîç [SERVICE] ===== OPERA√á√ÉO: NOVO CLIENTE =====")
                # Gerar ID √∫nico baseado em timestamp + random
                import random
                timestamp = int(datetime.now().timestamp())
                random_suffix = random.randint(100, 999)
                client['id'] = f"{timestamp}{random_suffix}"
                client['criadoEm'] = datetime.now().isoformat()
                print(f"üîç [SERVICE] ID gerado: {client['id']}")
                return self.add_new_client(client)
                
        except Exception as e:
            print(f"‚ùå [SERVICE] Erro ao processar cliente: {e}")
            import traceback
            print(f"‚ùå [SERVICE] Traceback: {traceback.format_exc()}")
            return False
    
    def add_new_client(self, client: Dict) -> bool:
        """Adiciona novo cliente na planilha"""
        try:
            print(f"‚ûï Adicionando novo cliente '{client.get('nomeEmpresa')}'...")
            
            row_data = self.client_to_row(client)
            body = {'values': [row_data]}
            
            result = self.service.spreadsheets().values().append(
                spreadsheetId=self.spreadsheet_id,
                range='Clientes!A:CZ',
                valueInputOption='USER_ENTERED',
                body=body
            ).execute()
            
            print(f"‚úÖ Novo cliente adicionado! Linhas: {result.get('updates', {}).get('updatedRows', 0)}")
            return True
            
        except Exception as e:
            print(f"‚ùå Erro ao adicionar cliente: {e}")
            return False
    
    def update_client(self, client: Dict) -> bool:
        """Atualiza cliente existente na planilha - CORRIGIDO PARA EVITAR DUPLICA√á√ÉO"""
        try:
            print(f"‚úèÔ∏è [SERVICE] ===== ATUALIZANDO CLIENTE =====")
            print(f"‚úèÔ∏è [SERVICE] Cliente ID: {client.get('id')}")
            print(f"‚úèÔ∏è [SERVICE] Nome: {client.get('nomeEmpresa')}")
            
            # Valida√ß√£o rigorosa
            client_id = client.get('id')
            if not client_id or str(client_id).strip() == '' or str(client_id) == 'None':
                print("‚ùå [SERVICE] ID do cliente √© inv√°lido para atualiza√ß√£o")
                return False
                
            if not client.get('nomeEmpresa'):
                print("‚ùå [SERVICE] Nome da empresa √© obrigat√≥rio")
                return False
            
            # Buscar a linha do cliente (DEVE existir)
            print("üîç [SERVICE] Localizando cliente na planilha...")
            row_index = self.find_client_row(client_id)
            print(f"üîç [SERVICE] Resultado da busca: {row_index}")
            
            if row_index <= 0:
                print(f"‚ùå [SERVICE] ERRO CR√çTICO: Cliente ID '{client_id}' n√£o encontrado!")
                print("‚ùå [SERVICE] ABORTAR atualiza√ß√£o para evitar duplica√ß√£o")
                return False
            
            # Manter dados originais importantes
            if not client.get('criadoEm'):
                print("üîç [SERVICE] Recuperando criadoEm original...")
                try:
                    existing_client = self.get_client(client_id)
                    if existing_client:
                        client['criadoEm'] = existing_client.get('criadoEm', datetime.now().isoformat())
                        print(f"‚úÖ [SERVICE] CriadoEm recuperado: {client['criadoEm']}")
                    else:
                        client['criadoEm'] = datetime.now().isoformat()
                        print(f"‚ö†Ô∏è [SERVICE] CriadoEm n√£o encontrado, usando atual")
                except Exception as e:
                    print(f"‚ö†Ô∏è [SERVICE] Erro ao recuperar criadoEm: {e}")
                    client['criadoEm'] = datetime.now().isoformat()
            
            # Garantir que est√° sendo uma atualiza√ß√£o
            client['ultimaAtualizacao'] = datetime.now().isoformat()
            
            # Preparar dados para atualiza√ß√£o
            print("üîß [SERVICE] Preparando dados para atualiza√ß√£o...")
            try:
                row_data = self.client_to_row(client)
                print(f"‚úÖ [SERVICE] Linha preparada: {len(row_data)} colunas")
                
                if len(row_data) < 93:
                    print(f"‚ö†Ô∏è [SERVICE] Linha tem menos colunas que esperado: {len(row_data)}")
                    
            except Exception as e:
                print(f"‚ùå [SERVICE] Erro ao preparar dados: {e}")
                return False
            
            # CORRE√á√ÉO: Verificar se a linha atual na planilha precisa ser expandida
            print("üîß [SERVICE] Verificando se linha atual precisa ser expandida...")
            try:
                # Buscar linha atual da planilha
                current_range = f'Clientes!A{row_index}:CZ{row_index}'
                current_result = self.service.spreadsheets().values().get(
                    spreadsheetId=self.spreadsheet_id,
                    range=current_range
                ).execute()
                
                current_row = current_result.get('values', [[]])[0] if current_result.get('values') else []
                print(f"üîç [SERVICE] Linha atual na planilha tem {len(current_row)} colunas")
                
                if len(current_row) < 93:
                    print(f"üîß [SERVICE] Expandindo linha de {len(current_row)} para 93 colunas...")
                    # Expandir a linha atual primeiro
                    expanded_row = current_row[:]
                    
                    # Se j√° tem o ID mas em posi√ß√£o errada, preservar
                    existing_id = client_id
                    if len(current_row) > 89 and current_row[89]:  # Se tinha ID na posi√ß√£o antiga
                        existing_id = current_row[89]
                    
                    # Expandir at√© 93 colunas
                    while len(expanded_row) < 93:
                        expanded_row.append('')
                    
                    # Colocar o ID na posi√ß√£o correta (√≠ndice 92)
                    expanded_row[92] = existing_id
                    
                    print(f"‚úÖ [SERVICE] Linha expandida para {len(expanded_row)} colunas com ID '{existing_id}' no √≠ndice 92")
                    
                    # Atualizar a planilha com a linha expandida primeiro
                    expand_body = {'values': [expanded_row]}
                    self.service.spreadsheets().values().update(
                        spreadsheetId=self.spreadsheet_id,
                        range=current_range,
                        valueInputOption='USER_ENTERED',
                        body=expand_body
                    ).execute()
                    
                    print("‚úÖ [SERVICE] Linha expandida na planilha com sucesso!")
                    
            except Exception as expand_error:
                print(f"‚ö†Ô∏è [SERVICE] Erro ao expandir linha: {expand_error}")
                # Continuar mesmo com erro de expans√£o
            
            # Executar atualiza√ß√£o
            range_name = f'Clientes!A{row_index}:CZ{row_index}'
            print(f"üîß [SERVICE] Atualizando range: {range_name}")
            
            body = {'values': [row_data]}
            
            try:
                result = self.service.spreadsheets().values().update(
                    spreadsheetId=self.spreadsheet_id,
                    range=range_name,
                    valueInputOption='USER_ENTERED',
                    body=body
                ).execute()
                
                updated_cells = result.get('updatedCells', 0)
                print(f"‚úÖ [SERVICE] Cliente atualizado com sucesso!")
                print(f"‚úÖ [SERVICE] Linha: {row_index}, C√©lulas: {updated_cells}")
                return True
                
            except Exception as api_error:
                print(f"‚ùå [SERVICE] Erro na API durante atualiza√ß√£o: {api_error}")
                return False
            
        except Exception as e:
            print(f"‚ùå [SERVICE] Erro geral ao atualizar cliente: {e}")
            import traceback
            print(f"‚ùå [SERVICE] Traceback: {traceback.format_exc()}")
            return False
    
    def find_client_row(self, client_id: str) -> int:
        """Encontra a linha do cliente na planilha - M√âTODO OTIMIZADO COM DEBUG PRODU√á√ÉO"""
        try:
            print(f"üîç [SERVICE] ===== BUSCANDO CLIENTE (PRODU√á√ÉO) =====")
            print(f"üîç [SERVICE] ID do cliente recebido: '{client_id}' (tipo: {type(client_id)})")
            print(f"üîç [SERVICE] Spreadsheet ID: {self.spreadsheet_id}")
            print(f"üîç [SERVICE] Range: {self.range_name}")
            
            if not client_id or str(client_id).strip() == '' or str(client_id) == 'None':
                print("‚ö†Ô∏è [SERVICE] ID do cliente est√° vazio ou None!")
                return -1
            
            # Normalizar o ID para busca
            search_id = str(client_id).strip()
            print(f"üîç [SERVICE] ID normalizado para busca: '{search_id}'")
            
            # Verificar se o servi√ßo est√° autenticado
            if not self.service:
                print("‚ùå [SERVICE] Servi√ßo Google Sheets n√£o est√° autenticado!")
                return -1
            
            # Buscar dados da planilha
            print("üîç [SERVICE] Fazendo requisi√ß√£o para Google Sheets...")
            result = self.service.spreadsheets().values().get(
                spreadsheetId=self.spreadsheet_id,
                range='Clientes!A:CZ'
            ).execute()
            
            values = result.get('values', [])
            print(f"üîç [SERVICE] Resposta da API recebida: {len(values)} linhas")
            
            if not values:
                print("‚ö†Ô∏è [SERVICE] Planilha vazia ou sem dados")
                return -1
            
            # Primeira linha s√£o os cabe√ßalhos
            headers = values[0] if values else []
            print(f"üîç [SERVICE] Planilha tem {len(values)} linhas no total")
            print(f"üîç [SERVICE] Cabe√ßalhos encontrados: {len(headers)} colunas")
            
            # Debug dos primeiros cabe√ßalhos
            if len(headers) >= 5:
                print(f"üîç [SERVICE] Primeiros 5 cabe√ßalhos: {headers[:5]}")
            if len(headers) >= 90:
                print(f"üîç [SERVICE] Cabe√ßalho da coluna 90 (ID): '{headers[89]}'")
            
            # Encontrar √≠ndice da coluna ID
            id_column_index = -1
            for i, header in enumerate(headers):
                if str(header).strip().upper() == 'ID':
                    id_column_index = i
                    print(f"üîç [SERVICE] Coluna ID encontrada no √≠ndice {i} (header: '{header}')")
                    break
            
            if id_column_index == -1:
                print("‚ùå [SERVICE] Coluna ID n√£o encontrada nos cabe√ßalhos!")
                print(f"‚ùå [SERVICE] Cabe√ßalhos dispon√≠veis: {[h for h in headers if h]}")
                return -1
            
            # Analisar primeiras linhas para debug
            print(f"üîç [SERVICE] ===== ANALISANDO PRIMEIRAS {min(5, len(values)-1)} LINHAS =====")
            for row_idx in range(1, min(6, len(values))):  # Come√ßar da linha 2 (√≠ndice 1)
                row = values[row_idx]
                print(f"üîç [SERVICE] Linha {row_idx + 1}: {len(row)} colunas")
                if id_column_index < len(row):
                    row_id = str(row[id_column_index]).strip()
                    print(f"üîç [SERVICE] Linha {row_idx + 1} - ID na posi√ß√£o {id_column_index}: '{row_id}'")
                else:
                    print(f"üîç [SERVICE] Linha {row_idx + 1} - Coluna ID n√£o existe (linha tem {len(row)} colunas)")
            
            # Buscar o ID espec√≠fico
            print(f"üîç [SERVICE] ===== BUSCANDO ID '{search_id}' =====")
            found_ids = []  # Para debug - coletar todos os IDs encontrados
            
            for row_idx in range(1, len(values)):  # Pular cabe√ßalho
                row = values[row_idx]
                if id_column_index < len(row):
                    row_id = str(row[id_column_index]).strip()
                    actual_row_number = row_idx + 1  # +1 porque √© 1-indexed
                    
                    # Coletar para debug
                    if row_id:  # S√≥ adicionar IDs n√£o vazios
                        found_ids.append(row_id)
                    
                    print(f"üîç [SERVICE] Linha {actual_row_number}: ID '{row_id}' vs busca '{search_id}' - Match: {row_id == search_id}")
                    if row_id == search_id:
                        print(f"‚úÖ [SERVICE] ===== CLIENTE ENCONTRADO NA LINHA {actual_row_number} =====")
                        return actual_row_number
            
            print(f"‚ùå [SERVICE] Cliente '{search_id}' n√£o encontrado")
            print(f"üîç [SERVICE] Total de IDs encontrados na planilha: {len(found_ids)}")
            print(f"üîç [SERVICE] Primeiros 10 IDs encontrados: {found_ids[:10]}")
            
            return -1
            
        except Exception as e:
            print(f"‚ùå [SERVICE] Erro ao buscar cliente: {e}")
            print(f"‚ùå [SERVICE] Tipo do erro: {type(e).__name__}")
            import traceback
            print(f"‚ùå [SERVICE] Traceback completo: {traceback.format_exc()}")
            return -1

    def get_client(self, client_id: str) -> Optional[Dict]:
        """Busca cliente espec√≠fico - COM DEBUG AVAN√áADO PARA PRODU√á√ÉO"""
        try:
            print(f"üîç [GET_CLIENT] ===== BUSCANDO CLIENTE ESPEC√çFICO (PRODU√á√ÉO) =====")
            print(f"üîç [GET_CLIENT] ID recebido: '{client_id}' (tipo: {type(client_id)})")
            print(f"üîç [GET_CLIENT] ID v√°lido: {bool(client_id and str(client_id).strip())}")
            
            if not client_id or str(client_id).strip() == '' or str(client_id) == 'None':
                print("‚ùå [GET_CLIENT] ID inv√°lido!")
                return None
            
            # Normalizar ID para busca
            search_id = str(client_id).strip()
            print(f"üîç [GET_CLIENT] ID normalizado: '{search_id}'")
            
            print("üîç [GET_CLIENT] Chamando find_client_row...")
            row_index = self.find_client_row(search_id)
            print(f"üîç [GET_CLIENT] Resultado find_client_row: {row_index}")
            
            if row_index <= 0:
                print(f"‚ùå [GET_CLIENT] Cliente '{search_id}' n√£o encontrado na planilha")
                print("üîç [GET_CLIENT] Tentando busca em todos os clientes como fallback...")
                
                # FALLBACK: Buscar em todos os clientes
                all_clients = self.get_clients()
                print(f"üîç [GET_CLIENT] Total de clientes na planilha: {len(all_clients)}")
                
                for client in all_clients:
                    client_existing_id = client.get('id', '')
                    if str(client_existing_id).strip() == search_id:
                        print(f"‚úÖ [GET_CLIENT] Cliente encontrado via fallback!")
                        print(f"‚úÖ [GET_CLIENT] Nome: {client.get('nomeEmpresa')}")
                        return client
                
                print(f"‚ùå [GET_CLIENT] Cliente '{search_id}' n√£o encontrado nem via fallback")
                return None
                
            # Buscar os dados da linha espec√≠fica
            range_name = f'Clientes!A{row_index}:CZ{row_index}'
            print(f"üîç [GET_CLIENT] Buscando dados do range: {range_name}")
            
            result = self.service.spreadsheets().values().get(
                spreadsheetId=self.spreadsheet_id,
                range=range_name
            ).execute()
            
            values = result.get('values', [])
            print(f"üîç [GET_CLIENT] Dados recebidos: {len(values)} linha(s)")
            
            if values and len(values[0]) > 0:
                print(f"üîç [GET_CLIENT] Primeira linha tem {len(values[0])} colunas")
                
                client = self.row_to_client(values[0])
                client['_row_number'] = row_index
                
                # Debug do cliente convertido
                converted_id = client.get('id', '')
                client_name = client.get('nomeEmpresa', 'N/A')
                
                print(f"‚úÖ [GET_CLIENT] Cliente convertido com sucesso!")
                print(f"‚úÖ [GET_CLIENT] Nome: '{client_name}'")
                print(f"‚úÖ [GET_CLIENT] ID convertido: '{converted_id}'")
                print(f"‚úÖ [GET_CLIENT] Linha: {row_index}")
                print(f"‚úÖ [GET_CLIENT] Total de campos no cliente: {len(client.keys())}")
                
                # Verificar se os IDs coincidem
                if str(converted_id).strip() != search_id:
                    print(f"‚ö†Ô∏è [GET_CLIENT] AVISO: ID convertido '{converted_id}' != ID buscado '{search_id}'")
                    print(f"‚ö†Ô∏è [GET_CLIENT] For√ßando ID correto...")
                    client['id'] = search_id
                
                return client
            else:
                print(f"‚ùå [GET_CLIENT] Dados vazios na linha {row_index}")
                return None
            
        except Exception as e:
            print(f"‚ùå [GET_CLIENT] Erro ao buscar cliente {client_id}: {e}")
            print(f"‚ùå [GET_CLIENT] Tipo do erro: {type(e).__name__}")
            import traceback
            print(f"‚ùå [GET_CLIENT] Traceback completo: {traceback.format_exc()}")
            return None
    
    def get_clients(self) -> List[Dict]:
        """Busca clientes da planilha - COM DEBUG PARA PRODU√á√ÉO"""
        try:
            print("üìä ===== BUSCANDO CLIENTES (PRODU√á√ÉO) =====")
            print(f"üìä Spreadsheet ID: {self.spreadsheet_id}")
            print(f"üìä Range: {self.range_name}")
            
            if not self.service:
                print("‚ùå Servi√ßo Google Sheets n√£o est√° autenticado!")
                return []
            
            print("üìä Fazendo requisi√ß√£o para Google Sheets...")
            result = self.service.spreadsheets().values().get(
                spreadsheetId=self.spreadsheet_id,
                range=self.range_name
            ).execute()
            
            values = result.get('values', [])
            print(f"üìä Resposta da API: {len(values)} linhas recebidas")
            
            if not values:
                print("üìù Nenhum cliente encontrado na planilha")
                return []
            
            # Debug dos cabe√ßalhos
            headers = values[0] if values else []
            print(f"üìä Cabe√ßalhos: {len(headers)} colunas")
            
            # Encontrar coluna ID para debug
            id_column_index = -1
            for i, header in enumerate(headers):
                if str(header).strip().upper() == 'ID':
                    id_column_index = i
                    break
            
            print(f"üìä Coluna ID encontrada no √≠ndice: {id_column_index}")
            
            clients = []
            rows_processed = 0
            rows_with_data = 0
            rows_with_valid_id = 0
            
            for i, row in enumerate(values[1:], 2):  # Skip header, start from row 2
                rows_processed += 1
                
                if len(row) > 0 and row[0]:  # Check if first column has value
                    rows_with_data += 1
                    
                    client = self.row_to_client(row)
                    client['_row_number'] = i  # Store row number for updates/deletes
                    
                    # Debug do ID do cliente
                    client_id = client.get('id', '')
                    if client_id and str(client_id).strip():
                        rows_with_valid_id += 1
                        if len(clients) < 5:  # Debug apenas dos primeiros 5
                            print(f"üìä Cliente {len(clients)+1}: '{client.get('nomeEmpresa')}' - ID: '{client_id}' - Linha: {i}")
                    
                    clients.append(client)
            
            print(f"üìä ===== RESUMO DA BUSCA =====")
            print(f"üìä Linhas processadas: {rows_processed}")
            print(f"üìä Linhas com dados: {rows_with_data}")
            print(f"üìä Linhas com ID v√°lido: {rows_with_valid_id}")
            print(f"üìä Total de clientes carregados: {len(clients)}")
            
            return clients
            
        except Exception as e:
            print(f"‚ùå Erro ao buscar clientes: {e}")
            print(f"‚ùå Tipo do erro: {type(e).__name__}")
            import traceback
            print(f"‚ùå Traceback completo: {traceback.format_exc()}")
            return []
    
    def delete_client(self, client_id: str) -> bool:
        """Remove cliente da planilha (exclus√£o real)"""
        try:
            print(f"üóëÔ∏è Deletando cliente ID: {client_id}")
            
            # Buscar a linha do cliente
            row_index = self.find_client_row(client_id)
            if row_index <= 0:
                print(f"‚ö†Ô∏è Cliente {client_id} n√£o encontrado")
                return False
            
            # Deletar a linha da planilha
            request_body = {
                'requests': [
                    {
                        'deleteDimension': {
                            'range': {
                                'sheetId': 0,  # Primeira aba da planilha
                                'dimension': 'ROWS',
                                'startIndex': row_index - 1,  # 0-based para API
                                'endIndex': row_index
                            }
                        }
                    }
                ]
            }
            
            result = self.service.spreadsheets().batchUpdate(
                spreadsheetId=self.spreadsheet_id,
                body=request_body
            ).execute()
            
            print(f"‚úÖ Cliente deletado da linha {row_index}")
            return True
            
        except Exception as e:
            print(f"‚ùå Erro ao deletar cliente: {e}")
            return False

    def get_headers(self) -> List[str]:
        """Retorna lista completa de cabe√ßalhos organizados por blocos"""
        return [
            # Bloco 1: Informa√ß√µes da Pessoa F√≠sica / Jur√≠dica (13 campos obrigat√≥rios)
            'NOME DA EMPRESA',                   # 1. Nome da empresa/fantasia
            'RAZ√ÉO SOCIAL NA RECEITA',           # 2. Nome oficial na Receita Federal
            'NOME FANTASIA NA RECEITA',          # 3. Nome fantasia na Receita Federal
            'CNPJ',                              # 4. CNPJ (14 d√≠gitos)
            'PERFIL',                            # 5. Perfil tribut√°rio (A, B, C, etc.)
            'INSCRI√á√ÉO ESTADUAL',                # 6. IE - Inscri√ß√£o Estadual
            'INSCRI√á√ÉO MUNICIPAL',               # 7. IM - Inscri√ß√£o Municipal
            'ESTADO',                            # 8. UF do Estado
            'CIDADE',                            # 9. Munic√≠pio
            'REGIME FEDERAL',                    # 10. Simples Nacional, Lucro Real, etc.
            'REGIME ESTADUAL',                   # 11. Normal, Simples, etc.
            'SEGMENTO',                          # 12. Ind√∫stria, Com√©rcio, Servi√ßos
            'ATIVIDADE',                         # 13. Atividade principal do neg√≥cio
            
            # Bloco 2: Servi√ßos Prestados pela Control
            'SERVI√áO CT',                        # 14. Contabilidade (SIM/N√ÉO)
            'SERVI√áO FS',                        # 15. Fiscal (SIM/N√ÉO)
            'SERVI√áO DP',                        # 16. Departamento Pessoal (SIM/N√ÉO)
            'SERVI√áO BPO FINANCEIRO',            # 17. BPO Financeiro (SIM/N√ÉO)
            'DATA IN√çCIO DOS SERVI√áOS',          # 18. Quando come√ßou a presta√ß√£o
            
            # C√≥digos dos Sistemas (Bloco 2)
            'C√ìDIGO FORTES CT',                  # 19. C√≥digo no sistema Fortes Cont√°bil
            'C√ìDIGO FORTES FS',                  # 20. C√≥digo no sistema Fortes Fiscal
            'C√ìDIGO FORTES PS',                  # 21. C√≥digo no sistema Fortes Pessoal
            'C√ìDIGO DOM√çNIO',                    # 22. C√≥digo no sistema Dom√≠nio
            'SISTEMA UTILIZADO',                 # 23. Sistema principal em uso
            'M√ìDULO SPED TRIER',                 # 24. M√≥dulo/vers√£o do SPED Trier
            
            # Bloco 3: Quadro Societ√°rio (campos base + din√¢micos)
            'S√ìCIO 1 NOME',                      # 25. Nome completo do s√≥cio 1
            'S√ìCIO 1 CPF',                       # 26. CPF do s√≥cio 1
            'S√ìCIO 1 DATA NASCIMENTO',           # 27. Data nascimento s√≥cio 1
            'S√ìCIO 1 ADMINISTRADOR',             # 28. √â administrador? (SIM/N√ÉO)
            'S√ìCIO 1 COTAS',                     # 29. Percentual de cotas
            'S√ìCIO 1 RESPONS√ÅVEL LEGAL',         # 30. Respons√°vel legal? (SIM/N√ÉO)
            
            # Bloco 4: Contatos
            'TELEFONE FIXO',                     # 31. Telefone comercial
            'TELEFONE CELULAR',                  # 32. Celular principal
            'WHATSAPP',                          # 33. N√∫mero do WhatsApp
            'EMAIL PRINCIPAL',                   # 34. Email principal da empresa
            'EMAIL SECUND√ÅRIO',                  # 35. Email alternativo
            'RESPONS√ÅVEL IMEDIATO',              # 36. Contato direto na empresa
            'EMAILS DOS S√ìCIOS',                 # 37. Emails dos s√≥cios
            'CONTATO CONTADOR',                  # 38. Nome do contador atual
            'TELEFONE CONTADOR',                 # 39. Telefone do contador
            'EMAIL CONTADOR',                    # 40. Email do contador
            
            # Bloco 5: Sistemas e Acessos
            'SISTEMA PRINCIPAL',                 # 42. ERP/Sistema principal
            'VERS√ÉO DO SISTEMA',                 # 43. Vers√£o/release
            'C√ìDIGO ACESSO SIMPLES NACIONAL',    # 44. C√≥digo de acesso SN
            'CPF/CNPJ PARA ACESSO',              # 45. CPF/CNPJ usado nos acessos
            'PORTAL CLIENTE ATIVO',              # 46. Portal ativo? (SIM/N√ÉO)
            'INTEGRA√á√ÉO DOM√çNIO',                # 47. Integrado Dom√≠nio? (SIM/N√ÉO)
            'SISTEMA ONVIO',                     # 48. Usa Onvio? (SIM/N√ÉO)
            'SISTEMA ONVIO CONT√ÅBIL',           # 49. Sistema Onvio Cont√°bil (SIM/N√ÉO)
            'SISTEMA ONVIO FISCAL',             # 50. Sistema Onvio Fiscal (SIM/N√ÉO)
            'SISTEMA ONVIO PESSOAL',            # 51. Sistema Onvio Pessoal (SIM/N√ÉO)
            
            # Bloco 6: Senhas e Credenciais
            'ACESSO ISS',                        # 49. Login ISS municipal
            'SENHA ISS',                         # 50. Senha ISS municipal
            'ACESSO SEFIN',                      # 51. Login SEFIN estadual
            'SENHA SEFIN',                       # 52. Senha SEFIN estadual
            'ACESSO SEUMA',                      # 53. Login SEUMA ambiental
            'SENHA SEUMA',                       # 54. Senha SEUMA ambiental
            'ACESSO EMPWEB',                     # 55. Login eSocial/EmpWeb
            'SENHA EMPWEB',                      # 56. Senha eSocial/EmpWeb
            'ACESSO FAP/INSS',                   # 57. Login FAP/INSS
            'SENHA FAP/INSS',                    # 58. Senha FAP/INSS
            'ACESSO CRF',                        # 59. Login CRF (farm√°cias)
            'SENHA CRF',                         # 60. Senha CRF (farm√°cias)
            'EMAIL GESTOR',                      # 61. Email para gest√£o
            'SENHA EMAIL GESTOR',                # 62. Senha email gest√£o
            'ANVISA GESTOR',                     # 63. Login ANVISA gestor
            'ANVISA EMPRESA',                    # 64. Login ANVISA empresa
            'ACESSO IBAMA',                      # 65. Login IBAMA
            'SENHA IBAMA',                       # 66. Senha IBAMA
            'ACESSO SEMACE',                     # 67. Login SEMACE estadual
            'SENHA SEMACE',                      # 68. Senha SEMACE estadual
            
            # Bloco 7: Procura√ß√µes
            'PROCURA√á√ÉO RFB',                    # 69. Tem procura√ß√£o RFB? (SIM/N√ÉO)
            'DATA PROCURA√á√ÉO RFB',               # 70. Data da procura√ß√£o RFB
            'PROCURA√á√ÉO RECEITA ESTADUAL',       # 71. Tem procura√ß√£o RE? (SIM/N√ÉO)
            'DATA PROCURA√á√ÉO RC',                # 72. Data da procura√ß√£o RC
            'PROCURA√á√ÉO CAIXA ECON√îMICA',        # 73. Tem procura√ß√£o CEF? (SIM/N√ÉO)
            'DATA PROCURA√á√ÉO CX',                # 74. Data da procura√ß√£o CX
            'PROCURA√á√ÉO PREVID√äNCIA SOCIAL',     # 75. Tem procura√ß√£o INSS? (SIM/N√ÉO)
            'DATA PROCURA√á√ÉO SW',                # 76. Data da procura√ß√£o SW
            'PROCURA√á√ÉO MUNICIPAL',              # 77. Tem procura√ß√£o municipal? (SIM/N√ÉO)
            'DATA PROCURA√á√ÉO MUNICIPAL',         # 78. Data da procura√ß√£o municipal
            'OUTRAS PROCURA√á√ïES',                # 79. Outras procura√ß√µes
            'OBSERVA√á√ïES PROCURA√á√ïES',           # 80. Obs sobre procura√ß√µes
            
            # Bloco 8: Observa√ß√µes e Dados Adicionais
            'OBSERVA√á√ïES GERAIS',                # 81. Observa√ß√µes livres
            'TAREFAS VINCULADAS',                # 82. N√∫mero de tarefas pendentes
            'DATA IN√çCIO SERVI√áOS',              # 83. Data in√≠cio (duplicate for compatibility)
            'STATUS DO CLIENTE',                 # 84. ATIVO, INATIVO, SUSPENSO
            '√öLTIMA ATUALIZA√á√ÉO',                # 85. Timestamp √∫ltima modifica√ß√£o
            'RESPONS√ÅVEL ATUALIZA√á√ÉO',           # 86. Quem fez a √∫ltima altera√ß√£o
            'PRIORIDADE',                        # 87. ALTA, NORMAL, BAIXA
            'TAGS/CATEGORIAS',                   # 88. Tags do cliente
            'HIST√ìRICO DE ALTERA√á√ïES',           # 89. Log de altera√ß√µes
            
            # Campos internos do sistema
            'DONO/RESPONS√ÅVEL',                  # 90. Dono/Respons√°vel (compatibilidade)
            'CLIENTE ATIVO',                     # 91. Cliente ativo? (SIM/N√ÉO)
            'DATA DE CRIA√á√ÉO',                   # 92. Data de cria√ß√£o do registro
            'ID',                                # 93. ID √∫nico do cliente
        ]

    def ensure_correct_headers(self):
        """Garante que os cabe√ßalhos estejam na ordem correta"""
        try:
            print("üîß Verificando cabe√ßalhos da planilha...")
            
            # Busca dados atuais
            result = self.service.spreadsheets().values().get(
                spreadsheetId=self.spreadsheet_id,
                range='Clientes!A1:CZ1'
            ).execute()
            
            current_headers = result.get('values', [[]])[0] if result.get('values') else []
            correct_headers = self.get_headers()
            
            # Se n√£o h√° cabe√ßalhos ou est√£o diferentes, atualiza
            if not current_headers or current_headers != correct_headers:
                print("üìù Atualizando cabe√ßalhos da planilha...")
                
                body = {
                    'values': [correct_headers]
                }
                
                self.service.spreadsheets().values().update(
                    spreadsheetId=self.spreadsheet_id,
                    range='Clientes!A1:CZ1',
                    valueInputOption='RAW',
                    body=body
                ).execute()
                
                print("‚úÖ Cabe√ßalhos atualizados com sucesso!")
            else:
                print("‚úÖ Cabe√ßalhos j√° est√£o corretos")
                
        except Exception as e:
            print(f"‚ùå Erro ao verificar/atualizar cabe√ßalhos: {e}")

    def client_to_row(self, client: Dict) -> List:
        """Converte cliente para linha da planilha - SIGEC organizado por blocos"""
        
        # DEBUG: Log do ID do cliente
        client_id = client.get('id', '')
        print(f"üîç [SERVICE] ===== CLIENT_TO_ROW =====")
        print(f"üîç [SERVICE] Cliente: {client.get('nomeEmpresa')}")
        print(f"üîç [SERVICE] ID do cliente: '{client_id}' (tipo: {type(client_id)})")
        print(f"üîç [SERVICE] ID ser√° colocado na posi√ß√£o 89 (coluna 90)")
        
        row_data = [
            # Bloco 1: Informa√ß√µes da Pessoa Jur√≠dica (13 campos obrigat√≥rios)
            client.get('nomeEmpresa', ''),                    # 1. NOME DA EMPRESA
            client.get('razaoSocialReceita', ''),             # 2. RAZ√ÉO SOCIAL NA RECEITA
            client.get('nomeFantasiaReceita', ''),            # 3. NOME FANTASIA NA RECEITA
            client.get('cnpj', ''),                           # 4. CNPJ
            client.get('perfil', ''),                         # 5. PERFIL
            client.get('inscEst', ''),                        # 6. INSCRI√á√ÉO ESTADUAL
            client.get('inscMun', ''),                        # 7. INSCRI√á√ÉO MUNICIPAL
            client.get('estado', ''),                         # 8. ESTADO
            client.get('cidade', ''),                         # 9. CIDADE
            client.get('regimeFederal', ''),                  # 10. REGIME FEDERAL
            client.get('regimeEstadual', ''),                 # 11. REGIME ESTADUAL
            client.get('segmento', ''),                       # 12. SEGMENTO
            client.get('atividade', ''),                      # 13. ATIVIDADE
            
            # Bloco 2: Servi√ßos Prestados pela Control
            'SIM' if client.get('ct') else 'N√ÉO',             # 14. SERVI√áO CT
            'SIM' if client.get('fs') else 'N√ÉO',             # 15. SERVI√áO FS
            'SIM' if client.get('dp') else 'N√ÉO',             # 16. SERVI√áO DP
            'SIM' if client.get('bpoFinanceiro') else 'N√ÉO',  # 17. SERVI√áO BPO FINANCEIRO
            '',                                               # 18. (REMOVIDO DUPLICA√á√ÉO - DATA IN√çCIO EST√Å NO √çNDICE 85)
            
            # C√≥digos dos Sistemas (Bloco 2)
            client.get('codFortesCt', ''),                    # 19. C√ìDIGO FORTES CT
            client.get('codFortesFs', ''),                    # 20. C√ìDIGO FORTES FS
            client.get('codFortesPs', ''),                    # 21. C√ìDIGO FORTES PS
            client.get('codDominio', ''),                     # 22. C√ìDIGO DOM√çNIO
            client.get('sistemaUtilizado', ''),               # 23. SISTEMA UTILIZADO
            client.get('moduloSpedTrier', ''),                # 24. M√ìDULO SPED TRIER
            
            # Bloco 3: Quadro Societ√°rio (campos base + din√¢micos)
            client.get('socio1_nome', client.get('socio1', '')),     # 25. S√ìCIO 1 NOME
            client.get('socio1_cpf', ''),                            # 26. S√ìCIO 1 CPF
            client.get('socio1_nascimento', ''),                     # 27. S√ìCIO 1 DATA NASCIMENTO
            'SIM' if client.get('socio1_admin') else 'N√ÉO',         # 28. S√ìCIO 1 ADMINISTRADOR
            client.get('socio1_cotas', ''),                          # 29. S√ìCIO 1 COTAS
            'SIM' if client.get('socio1_resp_legal') else 'N√ÉO',     # 30. S√ìCIO 1 RESPONS√ÅVEL LEGAL
            
            # Bloco 4: Contatos
            client.get('telefoneFixo', ''),                   # 31. TELEFONE FIXO
            client.get('telefoneCelular', ''),                # 32. TELEFONE CELULAR
            client.get('whatsapp', ''),                       # 33. WHATSAPP
            client.get('emailPrincipal', ''),                 # 34. EMAIL PRINCIPAL
            client.get('emailSecundario', ''),                # 35. EMAIL SECUND√ÅRIO
            client.get('responsavelImediato', ''),            # 36. RESPONS√ÅVEL IMEDIATO
            client.get('emailsSocios', ''),                   # 37. EMAILS DOS S√ìCIOS
            client.get('contatoContador', ''),                # 38. CONTATO CONTADOR
            client.get('telefoneContador', ''),               # 39. TELEFONE CONTADOR
            client.get('emailContador', ''),                  # 40. EMAIL CONTADOR
            
            # Bloco 5: Sistemas e Acessos
            client.get('sistemaPrincipal', ''),               # 42. SISTEMA PRINCIPAL
            client.get('versaoSistema', ''),                  # 43. VERS√ÉO DO SISTEMA
            client.get('codAcessoSimples', ''),               # 44. C√ìDIGO ACESSO SIMPLES NACIONAL
            client.get('cpfCnpjAcesso', ''),                  # 45. CPF/CNPJ PARA ACESSO
            'SIM' if client.get('portalClienteAtivo') else 'N√ÉO',    # 46. PORTAL CLIENTE ATIVO
            'SIM' if client.get('integracaoDominio') else 'N√ÉO',     # 47. INTEGRA√á√ÉO DOM√çNIO
            'SIM' if client.get('sistemaOnvio') else 'N√ÉO',          # 47. SISTEMA ONVIO (corrigido √≠ndice)
            'SIM' if client.get('sistemaOnvioContabil') else 'N√ÉO',  # 48. SISTEMA ONVIO CONT√ÅBIL (corrigido √≠ndice)
            'SIM' if client.get('sistemaOnvioFiscal') else 'N√ÉO',    # 49. SISTEMA ONVIO FISCAL (corrigido √≠ndice)
            'SIM' if client.get('sistemaOnvioPessoal') else 'N√ÉO',   # 50. SISTEMA ONVIO PESSOAL (corrigido √≠ndice)
            
            # Bloco 6: Senhas e Credenciais
            client.get('acessoIss', ''),                      # 52. ACESSO ISS
            client.get('senhaIss', ''),                       # 53. SENHA ISS
            client.get('acessoSefin', ''),                    # 54. ACESSO SEFIN
            client.get('senhaSefin', ''),                     # 55. SENHA SEFIN
            client.get('acessoSeuma', ''),                    # 56. ACESSO SEUMA
            client.get('senhaSeuma', ''),                     # 57. SENHA SEUMA
            client.get('acessoEmpWeb', ''),                   # 58. ACESSO EMPWEB
            client.get('senhaEmpWeb', ''),                    # 59. SENHA EMPWEB
            client.get('acessoFapInss', ''),                  # 60. ACESSO FAP/INSS
            client.get('senhaFapInss', ''),                   # 61. SENHA FAP/INSS
            client.get('acessoCrf', ''),                      # 62. ACESSO CRF
            client.get('senhaCrf', ''),                       # 63. SENHA CRF
            client.get('emailGestor', ''),                    # 64. EMAIL GESTOR
            client.get('senhaEmailGestor', ''),               # 65. SENHA EMAIL GESTOR
            client.get('anvisaGestor', ''),                   # 66. ANVISA GESTOR
            client.get('anvisaEmpresa', ''),                  # 67. ANVISA EMPRESA
            client.get('acessoIbama', ''),                    # 68. ACESSO IBAMA
            client.get('senhaIbama', ''),                     # 69. SENHA IBAMA
            client.get('acessoSemace', ''),                   # 70. ACESSO SEMACE
            client.get('senhaSemace', ''),                    # 71. SENHA SEMACE
            
            # Bloco 7: Procura√ß√µes
            'SIM' if client.get('procRfb') else 'N√ÉO',        # 72. PROCURA√á√ÉO RFB
            client.get('procRfbData', ''),                    # 73. DATA PROCURA√á√ÉO RFB
            'SIM' if client.get('procRc') else 'N√ÉO',         # 74. PROCURA√á√ÉO RECEITA ESTADUAL
            client.get('procRcData', ''),                     # 75. DATA PROCURA√á√ÉO RC
            'SIM' if client.get('procCx') else 'N√ÉO',         # 76. PROCURA√á√ÉO CAIXA ECON√îMICA
            client.get('procCxData', ''),                     # 77. DATA PROCURA√á√ÉO CX
            'SIM' if client.get('procSw') else 'N√ÉO',         # 78. PROCURA√á√ÉO PREVID√äNCIA SOCIAL
            client.get('procSwData', ''),                     # 79. DATA PROCURA√á√ÉO SW
            'SIM' if client.get('procMunicipal') else 'N√ÉO',  # 80. PROCURA√á√ÉO MUNICIPAL
            client.get('procMunicipalData', ''),              # 81. DATA PROCURA√á√ÉO MUNICIPAL
            client.get('outrasProc', ''),                     # 82. OUTRAS PROCURA√á√ïES
            client.get('obsProcuracoes', ''),                 # 83. OBSERVA√á√ïES PROCURA√á√ïES
            
            # Bloco 8: Observa√ß√µes e Dados Adicionais
            client.get('observacoesGerais', ''),              # 84. OBSERVA√á√ïES GERAIS
            client.get('tarefasVinculadas', 0),               # 85. TAREFAS VINCULADAS
            client.get('dataInicioServicos', ''),             # 86. DATA IN√çCIO SERVI√áOS
            client.get('statusCliente', 'ATIVO'),             # 87. STATUS DO CLIENTE
            client.get('ultimaAtualizacao', ''),              # 88. √öLTIMA ATUALIZA√á√ÉO
            client.get('responsavelAtualizacao', ''),         # 89. RESPONS√ÅVEL ATUALIZA√á√ÉO
            client.get('prioridadeCliente', 'NORMAL'),        # 90. PRIORIDADE
            client.get('tagsCliente', ''),                    # 91. TAGS/CATEGORIAS
            client.get('historicoAlteracoes', ''),            # 92. HIST√ìRICO DE ALTERA√á√ïES
            
            # Campos internos do sistema (tempor√°rios - ser√£o reposicionados)
            client.get('donoResp', ''),                       # 93. DONO/RESPONS√ÅVEL
            'SIM' if client.get('ativo', True) else 'N√ÉO',    # 94. CLIENTE ATIVO
        ]
        
        # CORRE√á√ÉO: Garantir que a linha tenha pelo menos 95 colunas
        # Preencher com strings vazias at√© atingir 95 colunas (√≠ndices 0-94)
        while len(row_data) < 95:
            row_data.append('')
        
        # Colocar o ID na posi√ß√£o correta (√≠ndice 94, que √© a coluna 95)
        row_data[94] = client.get('id', '')
        
        # DEBUG: Verificar se o ID foi colocado corretamente
        print(f"üîç [SERVICE] ID na posi√ß√£o 94: '{row_data[94]}' (deve ser '{client_id}')")
        print(f"‚úÖ [SERVICE] Total de colunas na linha: {len(row_data)}")
        print(f"‚úÖ [SERVICE] Linha preparada corretamente com ID no √≠ndice 94")
        
        return row_data
    
    def row_to_client(self, row: List) -> Dict:
        """Converte linha da planilha para dicion√°rio do cliente - SIGEC organizado por blocos"""
        def safe_get(row, index, default=''):
            try:
                return row[index] if index < len(row) and row[index] else default
            except:
                return default
                
        def bool_from_text(text, default=False):
            if isinstance(text, bool):
                return text
            if isinstance(text, str):
                return text.upper() in ['SIM', 'TRUE', '1', 'VERDADEIRO', 'S', 'YES']
            return default
        
        result = {
            # Bloco 1: Informa√ß√µes da Pessoa Jur√≠dica
            'nomeEmpresa': safe_get(row, 0),                    # 1. NOME DA EMPRESA
            'razaoSocialReceita': safe_get(row, 1),             # 2. RAZ√ÉO SOCIAL NA RECEITA
            'nomeFantasiaReceita': safe_get(row, 2),            # 3. NOME FANTASIA NA RECEITA
            'cnpj': safe_get(row, 3),                           # 4. CNPJ
            'perfil': safe_get(row, 4),                         # 5. PERFIL
            'inscEst': safe_get(row, 5),                        # 6. INSCRI√á√ÉO ESTADUAL
            'inscMun': safe_get(row, 6),                        # 7. INSCRI√á√ÉO MUNICIPAL
            'estado': safe_get(row, 7),                         # 8. ESTADO
            'cidade': safe_get(row, 8),                         # 9. CIDADE
            'regimeFederal': safe_get(row, 9),                  # 10. REGIME FEDERAL
            'regimeEstadual': safe_get(row, 10),                # 11. REGIME ESTADUAL
            'segmento': safe_get(row, 11),                      # 12. SEGMENTO
            'atividade': safe_get(row, 12),                     # 13. ATIVIDADE
            
            # Compatibilidade com campos legados
            'tributacao': safe_get(row, 9),                     # Alias para regimeFederal
            'cpfCnpj': safe_get(row, 3),                        # Alias para cnpj
            
            # Bloco 2: Servi√ßos Prestados pela Control
            'ct': bool_from_text(safe_get(row, 13)),            # 14. SERVI√áO CT
            'fs': bool_from_text(safe_get(row, 14)),            # 15. SERVI√áO FS
            'dp': bool_from_text(safe_get(row, 15)),            # 16. SERVI√áO DP
            'bpoFinanceiro': bool_from_text(safe_get(row, 16)), # 17. SERVI√áO BPO FINANCEIRO
            # 18. (REMOVIDO DUPLICA√á√ÉO - DATA IN√çCIO EST√Å NO √çNDICE 84)
            
            # C√≥digos dos Sistemas (Bloco 2)
            'codFortesCt': safe_get(row, 18),                   # 19. C√ìDIGO FORTES CT
            'codFortesFs': safe_get(row, 19),                   # 20. C√ìDIGO FORTES FS
            'codFortesPs': safe_get(row, 20),                   # 21. C√ìDIGO FORTES PS
            'codDominio': safe_get(row, 21),                    # 22. C√ìDIGO DOM√çNIO
            'sistemaUtilizado': safe_get(row, 22),              # 23. SISTEMA UTILIZADO
            'moduloSpedTrier': safe_get(row, 23),               # 24. M√ìDULO SPED TRIER
            
            # Bloco 3: Quadro Societ√°rio
            'socio1_nome': safe_get(row, 24),                   # 25. S√ìCIO 1 NOME
            'socio1_cpf': safe_get(row, 25),                    # 26. S√ìCIO 1 CPF
            'socio1_nascimento': safe_get(row, 26),             # 27. S√ìCIO 1 DATA NASCIMENTO
            'socio1_admin': bool_from_text(safe_get(row, 27)),  # 28. S√ìCIO 1 ADMINISTRADOR
            'socio1_cotas': safe_get(row, 28),                  # 29. S√ìCIO 1 COTAS
            'socio1_resp_legal': bool_from_text(safe_get(row, 29)), # 30. S√ìCIO 1 RESPONS√ÅVEL LEGAL
            
            # Campos legados para compatibilidade
            'socio1': safe_get(row, 24),                        # Alias para socio1_nome
            'mesAnoInicio': safe_get(row, 17),                  # Alias para dataInicioServicos
            
            # Bloco 4: Contatos
            'telefoneFixo': safe_get(row, 30),                  # 31. TELEFONE FIXO
            'telefoneCelular': safe_get(row, 31),               # 32. TELEFONE CELULAR
            'whatsapp': safe_get(row, 32),                      # 33. WHATSAPP
            'emailPrincipal': safe_get(row, 33),                # 34. EMAIL PRINCIPAL
            'emailSecundario': safe_get(row, 34),               # 35. EMAIL SECUND√ÅRIO
            'responsavelImediato': safe_get(row, 35),           # 36. RESPONS√ÅVEL IMEDIATO
            'emailsSocios': safe_get(row, 36),                  # 37. EMAILS DOS S√ìCIOS
            'contatoContador': safe_get(row, 37),               # 38. CONTATO CONTADOR
            'telefoneContador': safe_get(row, 38),              # 39. TELEFONE CONTADOR
            'emailContador': safe_get(row, 39),                 # 40. EMAIL CONTADOR
            
            # Campos legados para compatibilidade
            'emailsSocio': safe_get(row, 36),                   # Alias para emailsSocios
            
            # Bloco 5: Sistemas e Acessos
            'sistemaPrincipal': safe_get(row, 40),              # 41. SISTEMA PRINCIPAL
            'versaoSistema': safe_get(row, 42),                 # 43. VERS√ÉO DO SISTEMA
            'codAcessoSimples': safe_get(row, 43),              # 44. C√ìDIGO ACESSO SIMPLES NACIONAL
            'cpfCnpjAcesso': safe_get(row, 44),                 # 45. CPF/CNPJ PARA ACESSO
            'portalClienteAtivo': bool_from_text(safe_get(row, 45)), # 46. PORTAL CLIENTE ATIVO
            'integracaoDominio': bool_from_text(safe_get(row, 46)),  # 47. INTEGRA√á√ÉO DOM√çNIO
            'sistemaOnvio': bool_from_text(safe_get(row, 46)),  # 47. SISTEMA ONVIO (corrigido √≠ndice)
            'sistemaOnvioContabil': bool_from_text(safe_get(row, 47)), # 48. SISTEMA ONVIO CONT√ÅBIL (corrigido √≠ndice)
            'sistemaOnvioFiscal': bool_from_text(safe_get(row, 48)),   # 49. SISTEMA ONVIO FISCAL (corrigido √≠ndice)
            'sistemaOnvioPessoal': bool_from_text(safe_get(row, 49)),  # 50. SISTEMA ONVIO PESSOAL (corrigido √≠ndice)
            
            # Campos legados para compatibilidade
            'portalCliente': bool_from_text(safe_get(row, 45)), # Alias para portalClienteAtivo
            'integradoDominio': bool_from_text(safe_get(row, 46)), # Alias para integracaoDominio
            'onvio': bool_from_text(safe_get(row, 46)),         # Alias para sistemaOnvio (corrigido √≠ndice)
            
            # Bloco 6: Senhas e Credenciais
            'acessoIss': safe_get(row, 51),                     # 52. ACESSO ISS
            'senhaIss': safe_get(row, 52),                      # 53. SENHA ISS
            'acessoSefin': safe_get(row, 53),                   # 54. ACESSO SEFIN
            'senhaSefin': safe_get(row, 54),                    # 55. SENHA SEFIN
            'acessoSeuma': safe_get(row, 55),                   # 56. ACESSO SEUMA
            'senhaSeuma': safe_get(row, 56),                    # 57. SENHA SEUMA
            'acessoEmpWeb': safe_get(row, 57),                  # 58. ACESSO EMPWEB
            'senhaEmpWeb': safe_get(row, 58),                   # 59. SENHA EMPWEB
            'acessoFapInss': safe_get(row, 59),                 # 60. ACESSO FAP/INSS
            'senhaFapInss': safe_get(row, 60),                  # 61. SENHA FAP/INSS
            'acessoCrf': safe_get(row, 61),                     # 62. ACESSO CRF
            'senhaCrf': safe_get(row, 62),                      # 63. SENHA CRF
            'emailGestor': safe_get(row, 63),                   # 64. EMAIL GESTOR
            'senhaEmailGestor': safe_get(row, 64),              # 65. SENHA EMAIL GESTOR
            'anvisaGestor': safe_get(row, 65),                  # 66. ANVISA GESTOR
            'anvisaEmpresa': safe_get(row, 66),                 # 67. ANVISA EMPRESA
            'acessoIbama': safe_get(row, 67),                   # 68. ACESSO IBAMA
            'senhaIbama': safe_get(row, 68),                    # 69. SENHA IBAMA
            'acessoSemace': safe_get(row, 69),                  # 70. ACESSO SEMACE
            'senhaSemace': safe_get(row, 70),                   # 71. SENHA SEMACE
            
            # Bloco 7: Procura√ß√µes
            'procRfb': bool_from_text(safe_get(row, 71)),       # 72. PROCURA√á√ÉO RFB
            'procRfbData': safe_get(row, 72),                   # 73. DATA PROCURA√á√ÉO RFB
            'procRc': bool_from_text(safe_get(row, 73)),        # 74. PROCURA√á√ÉO RECEITA ESTADUAL
            'procRcData': safe_get(row, 74),                    # 75. DATA PROCURA√á√ÉO RC
            'procCx': bool_from_text(safe_get(row, 75)),        # 76. PROCURA√á√ÉO CAIXA ECON√îMICA
            'procCxData': safe_get(row, 76),                    # 77. DATA PROCURA√á√ÉO CX
            'procSw': bool_from_text(safe_get(row, 77)),        # 78. PROCURA√á√ÉO PREVID√äNCIA SOCIAL
            'procSwData': safe_get(row, 78),                    # 79. DATA PROCURA√á√ÉO SW
            'procMunicipal': bool_from_text(safe_get(row, 79)), # 80. PROCURA√á√ÉO MUNICIPAL
            'procMunicipalData': safe_get(row, 80),             # 81. DATA PROCURA√á√ÉO MUNICIPAL
            'outrasProc': safe_get(row, 81),                    # 82. OUTRAS PROCURA√á√ïES
            'obsProcuracoes': safe_get(row, 82),                # 83. OBSERVA√á√ïES PROCURA√á√ïES
            
            # Bloco 8: Observa√ß√µes e Dados Adicionais
            'observacoesGerais': safe_get(row, 83),             # 84. OBSERVA√á√ïES GERAIS
            'tarefasVinculadas': int(safe_get(row, 84, 0)) if str(safe_get(row, 84, 0)).isdigit() else 0, # 85. TAREFAS VINCULADAS 
            'dataInicioServicos': safe_get(row, 85),            # 86. DATA IN√çCIO SERVI√áOS (corrigido √≠ndice)
            'statusCliente': safe_get(row, 85, 'ATIVO'),        # 86. STATUS DO CLIENTE (corrigido √≠ndice)
            'ultimaAtualizacao': safe_get(row, 86),             # 87. √öLTIMA ATUALIZA√á√ÉO (corrigido √≠ndice)
            'responsavelAtualizacao': safe_get(row, 87),        # 88. RESPONS√ÅVEL ATUALIZA√á√ÉO (corrigido √≠ndice)
            'prioridadeCliente': safe_get(row, 88, 'NORMAL'),   # 89. PRIORIDADE (corrigido √≠ndice)
            'tagsCliente': safe_get(row, 89),                   # 90. TAGS/CATEGORIAS (corrigido √≠ndice)
            'historicoAlteracoes': safe_get(row, 90),           # 91. HIST√ìRICO DE ALTERA√á√ïES (corrigido √≠ndice)
            
            # Campos internos do sistema
            'id': safe_get(row, 94),                            # 95. ID
            'ativo': bool_from_text(safe_get(row, 92, 'SIM'), True), # 93. CLIENTE ATIVO (corrigido √≠ndice)
            'criadoEm': safe_get(row, 95, datetime.now().isoformat()) # 96. DATA DE CRIA√á√ÉO (corrigido)
        }
        
        # DEBUG e VALIDA√á√ÉO do ID
        client_id = result.get('id', '')
        nome_empresa = result.get('nomeEmpresa', 'N/A')
        
        # Se o ID estiver vazio, gerar um baseado no nome da empresa e timestamp
        if not client_id or str(client_id).strip() == '':
            print(f"‚ö†Ô∏è [ROW_TO_CLIENT] Cliente '{nome_empresa}' sem ID! Gerando ID tempor√°rio...")
            
            # Gerar ID baseado no nome da empresa (primeiros 3 chars + timestamp)
            safe_name = ''.join(c for c in nome_empresa[:3] if c.isalnum()).upper()
            timestamp_id = int(datetime.now().timestamp())
            temp_id = f"{safe_name}{timestamp_id}"
            result['id'] = temp_id
            print(f"‚ö†Ô∏è [ROW_TO_CLIENT] ID tempor√°rio gerado: '{temp_id}'")
        else:
            print(f"‚úÖ [ROW_TO_CLIENT] Cliente '{nome_empresa}' com ID v√°lido: '{client_id}'")
        
        return result
    
    def worksheet_exists(self, worksheet_name: str) -> bool:
        """Verifica se uma aba (worksheet) existe na planilha"""
        try:
            # Obter metadados da planilha
            spreadsheet = self.service.spreadsheets().get(
                spreadsheetId=self.spreadsheet_id
            ).execute()
            
            # Verificar se a aba existe
            for sheet in spreadsheet.get('sheets', []):
                sheet_title = sheet.get('properties', {}).get('title', '')
                if sheet_title == worksheet_name:
                    return True
                    
            return False
            
        except Exception as e:
            print(f"‚ùå Erro ao verificar exist√™ncia da aba '{worksheet_name}': {e}")
            return False
    
    def create_worksheet(self, worksheet_name: str, headers: List[str] = None) -> bool:
        """Cria uma nova aba (worksheet) na planilha"""
        try:
            print(f"üìù Criando aba '{worksheet_name}'...")
            
            # Criar a aba
            requests = [{
                'addSheet': {
                    'properties': {
                        'title': worksheet_name
                    }
                }
            }]
            
            body = {'requests': requests}
            
            self.service.spreadsheets().batchUpdate(
                spreadsheetId=self.spreadsheet_id,
                body=body
            ).execute()
            
            print(f"‚úÖ Aba '{worksheet_name}' criada com sucesso!")
            
            # Se headers foram fornecidos, adiciona-los
            if headers:
                print(f"üìù Adicionando cabe√ßalhos √† aba '{worksheet_name}'...")
                body = {
                    'values': [headers]
                }
                
                self.service.spreadsheets().values().update(
                    spreadsheetId=self.spreadsheet_id,
                    range=f"{worksheet_name}!A1",
                    valueInputOption='USER_ENTERED',
                    body=body
                ).execute()
                
                print(f"‚úÖ Cabe√ßalhos adicionados √† aba '{worksheet_name}'!")
            
            return True
            
        except Exception as e:
            print(f"‚ùå Erro ao criar aba '{worksheet_name}': {e}")
            return False
    
    def get_worksheet_data(self, worksheet_name: str, range_suffix: str = "A:Z") -> List[List]:
        """Obt√©m dados de uma aba espec√≠fica"""
        try:
            range_name = f"{worksheet_name}!{range_suffix}"
            
            result = self.service.spreadsheets().values().get(
                spreadsheetId=self.spreadsheet_id,
                range=range_name
            ).execute()
            
            return result.get('values', [])
            
        except Exception as e:
            print(f"‚ùå Erro ao obter dados da aba '{worksheet_name}': {e}")
            return []
    
    def append_to_worksheet(self, worksheet_name: str, data: List[List]) -> bool:
        """Adiciona dados ao final de uma aba"""
        try:
            range_name = f"{worksheet_name}!A:Z"
            
            body = {
                'values': data
            }
            
            result = self.service.spreadsheets().values().append(
                spreadsheetId=self.spreadsheet_id,
                range=range_name,
                valueInputOption='USER_ENTERED',
                body=body
            ).execute()
            
            rows_added = result.get('updates', {}).get('updatedRows', 0)
            print(f"‚úÖ {rows_added} linha(s) adicionada(s) √† aba '{worksheet_name}'")
            
            return True
            
        except Exception as e:
            print(f"‚ùå Erro ao adicionar dados √† aba '{worksheet_name}': {e}")
            return False
    
    def get_worksheet(self, worksheet_name: str):
        """Obt√©m refer√™ncia para uma aba espec√≠fica (compatibilidade com gspread)"""
        # Este m√©todo √© chamado por alguns servi√ßos que esperam compatibilidade com gspread
        # Como estamos usando Google API diretamente, retornamos um objeto simulado
        class WorksheetShim:
            def __init__(self, service, spreadsheet_id, worksheet_name):
                self.service = service
                self.spreadsheet_id = spreadsheet_id
                self.worksheet_name = worksheet_name
            
            def get_all_values(self):
                """Simula gspread.get_all_values()"""
                try:
                    result = self.service.spreadsheets().values().get(
                        spreadsheetId=self.spreadsheet_id,
                        range=f"{self.worksheet_name}!A:Z"
                    ).execute()
                    return result.get('values', [])
                except Exception as e:
                    print(f"‚ùå Erro ao obter valores da aba '{self.worksheet_name}': {e}")
                    return []
            
            def append_row(self, row_data):
                """Simula gspread.append_row()"""
                try:
                    body = {'values': [row_data]}
                    result = self.service.spreadsheets().values().append(
                        spreadsheetId=self.spreadsheet_id,
                        range=f"{self.worksheet_name}!A:Z",
                        valueInputOption='USER_ENTERED',
                        body=body
                    ).execute()
                    return True
                except Exception as e:
                    print(f"‚ùå Erro ao adicionar linha √† aba '{self.worksheet_name}': {e}")
                    return False
            
            def row_values(self, row_number):
                """Simula gspread.row_values()"""
                try:
                    range_name = f"{self.worksheet_name}!{row_number}:{row_number}"
                    result = self.service.spreadsheets().values().get(
                        spreadsheetId=self.spreadsheet_id,
                        range=range_name
                    ).execute()
                    values = result.get('values', [])
                    return values[0] if values else []
                except Exception as e:
                    print(f"‚ùå Erro ao obter linha {row_number} da aba '{self.worksheet_name}': {e}")
                    return []
            
            @property
            def row_count(self):
                """Simula gspread.row_count"""
                try:
                    all_values = self.get_all_values()
                    return len(all_values)
                except Exception as e:
                    print(f"‚ùå Erro ao contar linhas da aba '{self.worksheet_name}': {e}")
                    return 0
            
            def insert_row(self, values, index=1):
                """Simula gspread.insert_row()"""
                try:
                    # Para inserir uma linha no in√≠cio, precisamos usar batchUpdate
                    requests = [{
                        'insertDimension': {
                            'range': {
                                'sheetId': self._get_sheet_id(),
                                'dimension': 'ROWS',
                                'startIndex': index - 1,
                                'endIndex': index
                            },
                            'inheritFromBefore': False
                        }
                    }]
                    
                    body = {'requests': requests}
                    self.service.spreadsheets().batchUpdate(
                        spreadsheetId=self.spreadsheet_id,
                        body=body
                    ).execute()
                    
                    # Agora adiciona os valores na linha inserida
                    range_name = f"{self.worksheet_name}!A{index}:Z{index}"
                    body = {'values': [values]}
                    
                    self.service.spreadsheets().values().update(
                        spreadsheetId=self.spreadsheet_id,
                        range=range_name,
                        valueInputOption='USER_ENTERED',
                        body=body
                    ).execute()
                    
                    return True
                except Exception as e:
                    print(f"‚ùå Erro ao inserir linha na aba '{self.worksheet_name}': {e}")
                    return False
            
            def _get_sheet_id(self):
                """Obt√©m o ID da aba para opera√ß√µes batch"""
                try:
                    spreadsheet = self.service.spreadsheets().get(
                        spreadsheetId=self.spreadsheet_id
                    ).execute()
                    
                    for sheet in spreadsheet.get('sheets', []):
                        if sheet.get('properties', {}).get('title') == self.worksheet_name:
                            return sheet.get('properties', {}).get('sheetId', 0)
                    
                    return 0
                except Exception as e:
                    print(f"‚ùå Erro ao obter ID da aba '{self.worksheet_name}': {e}")
                    return 0
        
        return WorksheetShim(self.service, self.spreadsheet_id, worksheet_name)
